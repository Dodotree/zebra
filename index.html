<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>Zebra</title>
        <link rel="stylesheet" href="./index.css" />
    </head>

    <body>
        <header>
            <h1>WebCam Tuner</h1>
        </header>

        <main>


            <!-- Fragment shader program for depth -->
            <!-- Only difference is in multiplication -->
            <script id="depth-fs" type="x-shader/x-fragment">
                precision mediump float;
                uniform sampler2D s;
                varying vec2 t;

                void main(void)
                {
                    vec4 tex=texture2D(s,t) * vec4(10.0, 10.0, 10.0, 1.0);
                    gl_FragColor=tex.rgba;
                }
            </script>





    <!-- Vertex shader program -->
    <script id="shader-vs" type="x-shader/x-vertex">
        #version 300 es
        in vec4 a_position;
        void main() {
            gl_Position = a_position - 0.5;
        }
    </script>

    <!-- Fragment shader program -->
    <script id="packing-fs" type="x-shader/x-fragment">
        #version 300 es
        // precision mediump float;
        precision highp float;
        uniform sampler2D u_texture;

        layout(location = 0) out vec4 outColor;
        layout(location = 1) out vec4 fragCoord;

        int iwidth = 8; // width of the pixel block, packed into 8 bits
        int iheight = 4; // height of the pixel block, packed into RGBA channels
        vec4 bytes = vec4(0.0, 0.0, 0.0, 0.0);

        void main() {

            // gl_FragCoord gives exact pixel coordinates in window space, not interpolated
            // in the middle of the pixel (0.5, 0.5) for pixel (0, 0)
            int x = int(gl_FragCoord.x - 0.5) * 8;
            int y = int(gl_FragCoord.y - 0.5) * 4;
            ivec2 xy = ivec2(x, y);
            for (int j = 0; j < iheight; j++) {
                uint byteValue = uint(0);
                for(int i = 0; i < iwidth; i++) {
                    float normCol = texelFetch(u_texture, xy + ivec2(i,j), 0).r;
                    if (normCol > 0.24) {
                        byteValue =  byteValue | (uint(1) << uint(i));
                    }
                }
                bytes[j] = float(byteValue) / 255.0; // normalize to [0, 1] range
            }
            outColor = bytes;
            fragCoord = gl_FragCoord;
        }
    </script>

    <!-- Fragment shader program -->
    <script id="processing-fs-0" type="x-shader/x-fragment">
        #version 300 es
        // precision mediump float;
        precision highp float;
        uniform sampler2D p_texture;
        out vec4 outColor;

        int iwidth = 8; // width of the pixel block, packed into 8 bits
        int iheight = 4; // height of the pixel block, packed into RGBA channels

        bool[60] getDataBock(sampler2D tex, int w, int h) {
            bool[60] data; // 32 bits and 28 bits of surrounding 1 pixel neighbors
            ivec2 xy = ivec2(gl_FragCoord.xy - 0.5);
            vec4 cell = texelFetch(tex, xy, 0) * 255.0;
            vec4 cellL = texelFetch(tex, xy + ivec2(-1,0), 0) * 255.0;
            vec4 cellR = texelFetch(tex, xy + ivec2(1,0), 0) * 255.0;
            uint byteT = uint(texelFetch(tex, xy + ivec2(0,-1), 0)[h-1] * 255.0);
            uint byteB = uint(texelFetch(tex, xy + ivec2(0,1), 0)[0] * 255.0);
            for (int j = 0; j < h; j++) {
                uint byte = uint(cell[j]);
                for(int i = 0; i < w; i++) {
                    data[10*j+i+11] = bool(byte & (uint(1) << uint(i)));
                }
                data[10*j+10] = bool(uint(cellL[j]) & (uint(1) << uint(w-1)) );
                data[10*j+19] = bool(uint(cellR[j]) & (uint(1) << uint(0)) );
            }
            for(int i = 0; i < w; i++) {
                data[i+1] = bool(byteT & (uint(1) << uint(i)));
                data[i+51] = bool(byteB & (uint(1) << uint(i)));
            }
            for(int j = 0; j < 2; j++) {
                for(int i = 0; i < 2; i++) {
                    uint byteCorner = uint(texelFetch(tex, xy + ivec2(2*i-1, 2*j-1), 0)[3*(1-j)] * 255.0);
                    data[50*j+9*i] = bool(byteCorner & (uint(1) << uint((w-1)*(1-i))));
                }
            }
            return data;
        }

        bool getProcessedBit(bool[9] box) {

            // rotation 0°
            // sel_4_1     sel_4_2     sel_4_3
            // 0,0,1       0,0,1       0,2,0
            // 2,0,1       2,0,1       2,0,1
            // 0,0,1       0,2,0       0,0,1

            // sel_4_1  0° rotation:
            bool val0 = box[2];     // Hit at above_right (1, -1)
            val0 =  val0 && (!box[3]);     // Miss at left (-1, 0)
            val0 = val0 && box[5];     // Hit at right (1, 0)
            val0 = val0 && box[8];     // Hit at below_right (1, 1)

            // sel_4_2  0° rotation:
            bool val1 = box[2];     // Hit at above_right (1, -1)
            val1 =  val1 && (!box[3]);     // Miss at left (-1, 0)
            val1 = val1 && box[5];     // Hit at right (1, 0)
            val1 =  val1 && (!box[7]);     // Miss at below (0, 1)

            // sel_4_3  0° rotation:
            bool val2 =  (!box[1]);     // Miss at above (0, -1)
            val2 =  val2 && (!box[3]);     // Miss at left (-1, 0)
            val2 = val2 && box[5];     // Hit at right (1, 0)
            val2 = val2 && box[8];     // Hit at below_right (1, 1)

            bool val = val0 || val1 || val2;
            val = box[4] && (!val); // box[4] - center pixel

            return !val;
        }


        void main() {

            bool[60] data = getDataBock(p_texture, iwidth, iheight);

            // process main 32 bits and pack the result back into the pixel
            vec4 bytes = vec4(0.0, 0.0, 0.0, 0.0);
            for (int j = 0; j < iheight; j++) {
                uint byteValue = uint(0);
                for(int i = 0; i < iwidth; i++) {
                    int cXY = 10*j + i; // corner XY index for (-1,-1) to (1,1) box

                    // inversions due to Leptonica algorithm treating white as ink
                    // so it thickens black and thins white (for thinning)
                    bool[9] box = bool[9](
                        !data[cXY], !data[cXY+1], !data[cXY+2],
                        !data[cXY+10], !data[cXY+11], !data[cXY+12],
                        !data[cXY+20], !data[cXY+21], !data[cXY+22]
                    );
                    if (getProcessedBit(box)) {
                        byteValue =  byteValue | (uint(1) << uint(i));
                    }
                }
                bytes[j] = float(byteValue) / 255.0; // normalize to [0, 1] range
            }

            outColor = bytes;
        }
    </script>


    <!-- Fragment shader program -->
    <script id="processing-fs-90" type="x-shader/x-fragment">
        #version 300 es
        // precision mediump float;
        precision highp float;
        uniform sampler2D p_texture;
        out vec4 outColor;

        int iwidth = 8; // width of the pixel block, packed into 8 bits
        int iheight = 4; // height of the pixel block, packed into RGBA channels

        bool[60] getDataBock(sampler2D tex, int w, int h) {
            bool[60] data; // 32 bits and 28 bits of surrounding 1 pixel neighbors
            ivec2 xy = ivec2(gl_FragCoord.xy - 0.5);
            vec4 cell = texelFetch(tex, xy, 0) * 255.0;
            vec4 cellL = texelFetch(tex, xy + ivec2(-1,0), 0) * 255.0;
            vec4 cellR = texelFetch(tex, xy + ivec2(1,0), 0) * 255.0;
            uint byteT = uint(texelFetch(tex, xy + ivec2(0,-1), 0)[h-1] * 255.0);
            uint byteB = uint(texelFetch(tex, xy + ivec2(0,1), 0)[0] * 255.0);
            for (int j = 0; j < h; j++) {
                uint byte = uint(cell[j]);
                for(int i = 0; i < w; i++) {
                    data[10*j+i+11] = bool(byte & (uint(1) << uint(i)));
                }
                data[10*j+10] = bool(uint(cellL[j]) & (uint(1) << uint(w-1)) );
                data[10*j+19] = bool(uint(cellR[j]) & (uint(1) << uint(0)) );
            }
            for(int i = 0; i < w; i++) {
                data[i+1] = bool(byteT & (uint(1) << uint(i)));
                data[i+51] = bool(byteB & (uint(1) << uint(i)));
            }
            for(int j = 0; j < 2; j++) {
                for(int i = 0; i < 2; i++) {
                    uint byteCorner = uint(texelFetch(tex, xy + ivec2(2*i-1, 2*j-1), 0)[3*(1-j)] * 255.0);
                    data[50*j+9*i] = bool(byteCorner & (uint(1) << uint((w-1)*(1-i))));
                }
            }
            return data;
        }

        bool getProcessedBit(bool[9] box) {

            // rotation 90°
            // sel_4_1     sel_4_2     sel_4_3
            // 0,2,0       0,2,0       0,2,0
            // 0,0,0       2,0,0       0,0,2
            // 1,1,1       0,1,1       1,1,0

            // sel_4_1  90° rotation:
            bool val0 = (!box[1]);     // Miss at above (0, -1)
            val0 = val0 && box[6];     // Hit at below_left (-1, 1)
            val0 = val0 && box[7];     // Hit at below (0, 1)
            val0 = val0 && box[8];     // Hit at below_right (1, 1)

            // sel_4_2  90° rotation:
            bool val1 = (!box[1]);     // Miss at above (0, -1)
            val1 = val1 && (!box[3]);     // Miss at left (-1, 0)
            val1 = val1 && box[7];     // Hit at below (0, 1)
            val1 = val1 && box[8];     // Hit at below_right (1, 1)

            // sel_4_3  90° rotation:
            bool val2 = (!box[1]);     // Miss at above (0, -1)
            val2 = val2 && (!box[5]);     // Miss at right (1, 0)
            val2 = val2 && box[6];     // Hit at below_left (-1, 1)
            val2 = val2 && box[7];     // Hit at below (0, 1)

            bool val = val0 || val1 || val2;
            val = box[4] && (!val); // box[4] - center pixel

            return !val;
        }


        void main() {

            bool[60] data = getDataBock(p_texture, iwidth, iheight);

            // process main 32 bits and pack the result back into the pixel
            vec4 bytes = vec4(0.0, 0.0, 0.0, 0.0);
            for (int j = 0; j < iheight; j++) {
                uint byteValue = uint(0);
                for(int i = 0; i < iwidth; i++) {
                    int cXY = 10*j + i; // corner XY index for (-1,-1) to (1,1) box

                    // inversions due to Leptonica algorithm treating white as ink
                    // so it thickens black and thins white (for thinning)
                    bool[9] box = bool[9](
                        !data[cXY], !data[cXY+1], !data[cXY+2],
                        !data[cXY+10], !data[cXY+11], !data[cXY+12],
                        !data[cXY+20], !data[cXY+21], !data[cXY+22]
                    );
                    if (getProcessedBit(box)) {
                        byteValue =  byteValue | (uint(1) << uint(i));
                    }
                }
                bytes[j] = float(byteValue) / 255.0; // normalize to [0, 1] range
            }

            outColor = bytes;
        }
    </script>


    <!-- Fragment shader program -->
    <script id="processing-fs-180" type="x-shader/x-fragment">
        #version 300 es
        // precision mediump float;
        precision highp float;
        uniform sampler2D p_texture;
        out vec4 outColor;

        int iwidth = 8; // width of the pixel block, packed into 8 bits
        int iheight = 4; // height of the pixel block, packed into RGBA channels

        bool[60] getDataBock(sampler2D tex, int w, int h) {
            bool[60] data; // 32 bits and 28 bits of surrounding 1 pixel neighbors
            ivec2 xy = ivec2(gl_FragCoord.xy - 0.5);
            vec4 cell = texelFetch(tex, xy, 0) * 255.0;
            vec4 cellL = texelFetch(tex, xy + ivec2(-1,0), 0) * 255.0;
            vec4 cellR = texelFetch(tex, xy + ivec2(1,0), 0) * 255.0;
            uint byteT = uint(texelFetch(tex, xy + ivec2(0,-1), 0)[h-1] * 255.0);
            uint byteB = uint(texelFetch(tex, xy + ivec2(0,1), 0)[0] * 255.0);
            for (int j = 0; j < h; j++) {
                uint byte = uint(cell[j]);
                for(int i = 0; i < w; i++) {
                    data[10*j+i+11] = bool(byte & (uint(1) << uint(i)));
                }
                data[10*j+10] = bool(uint(cellL[j]) & (uint(1) << uint(w-1)) );
                data[10*j+19] = bool(uint(cellR[j]) & (uint(1) << uint(0)) );
            }
            for(int i = 0; i < w; i++) {
                data[i+1] = bool(byteT & (uint(1) << uint(i)));
                data[i+51] = bool(byteB & (uint(1) << uint(i)));
            }
            for(int j = 0; j < 2; j++) {
                for(int i = 0; i < 2; i++) {
                    uint byteCorner = uint(texelFetch(tex, xy + ivec2(2*i-1, 2*j-1), 0)[3*(1-j)] * 255.0);
                    data[50*j+9*i] = bool(byteCorner & (uint(1) << uint((w-1)*(1-i))));
                }
            }
            return data;
        }

        bool getProcessedBit(bool[9] box) {

            // rotation 180°
            // sel_4_1     sel_4_2     sel_4_3
            // 1,0,0       0,2,0       1,0,0
            // 1,0,2       1,0,2       1,0,2
            // 1,0,0       1,0,0       0,2,0

            // sel_4_1  180° rotation:
            bool val0 = box[0];     // Hit at above_left (-1, -1)
            val0 = val0 && box[3];     // Hit at left (-1, 0)
            val0 = val0 && (!box[5]);     // Miss at right (1, 0)
            val0 = val0 && box[6];     // Hit at below_left (-1, 1)

            // sel_4_2  180° rotation:
            bool val1 = (!box[1]);     // Miss at above (0, -1)
            val1 = val1 && box[3];     // Hit at left (-1, 0)
            val1 = val1 && (!box[5]);     // Miss at right (1, 0)
            val1 = val1 && box[6];     // Hit at below_left (-1, 1)

            // sel_4_3  180° rotation:
            bool val2 = box[0];     // Hit at above_left (-1, -1)
            val2 = val2 && box[3];     // Hit at left (-1, 0)
            val2 = val2 && (!box[5]);     // Miss at right (1, 0)
            val2 = val2 && (!box[7]);     // Miss at below (0, 1)

            bool val = val0 || val1 || val2;
            val = box[4] && (!val); // box[4] - center pixel

            return !val;
        }


        void main() {

            bool[60] data = getDataBock(p_texture, iwidth, iheight);

            // process main 32 bits and pack the result back into the pixel
            vec4 bytes = vec4(0.0, 0.0, 0.0, 0.0);
            for (int j = 0; j < iheight; j++) {
                uint byteValue = uint(0);
                for(int i = 0; i < iwidth; i++) {
                    int cXY = 10*j + i; // corner XY index for (-1,-1) to (1,1) box

                    // inversions due to Leptonica algorithm treating white as ink
                    // so it thickens black and thins white (for thinning)
                    bool[9] box = bool[9](
                        !data[cXY], !data[cXY+1], !data[cXY+2],
                        !data[cXY+10], !data[cXY+11], !data[cXY+12],
                        !data[cXY+20], !data[cXY+21], !data[cXY+22]
                    );
                    if (getProcessedBit(box)) {
                        byteValue =  byteValue | (uint(1) << uint(i));
                    }
                }
                bytes[j] = float(byteValue) / 255.0; // normalize to [0, 1] range
            }

            outColor = bytes;
        }
    </script>


    <!-- Fragment shader program -->
    <script id="processing-fs-270" type="x-shader/x-fragment">
        #version 300 es
        // precision mediump float;
        precision highp float;
        uniform sampler2D p_texture;
        out vec4 outColor;

        int iwidth = 8; // width of the pixel block, packed into 8 bits
        int iheight = 4; // height of the pixel block, packed into RGBA channels

        bool[60] getDataBock(sampler2D tex, int w, int h) {
            bool[60] data; // 32 bits and 28 bits of surrounding 1 pixel neighbors
            ivec2 xy = ivec2(gl_FragCoord.xy - 0.5);
            vec4 cell = texelFetch(tex, xy, 0) * 255.0;
            vec4 cellL = texelFetch(tex, xy + ivec2(-1,0), 0) * 255.0;
            vec4 cellR = texelFetch(tex, xy + ivec2(1,0), 0) * 255.0;
            uint byteT = uint(texelFetch(tex, xy + ivec2(0,-1), 0)[h-1] * 255.0);
            uint byteB = uint(texelFetch(tex, xy + ivec2(0,1), 0)[0] * 255.0);
            for (int j = 0; j < h; j++) {
                uint byte = uint(cell[j]);
                for(int i = 0; i < w; i++) {
                    data[10*j+i+11] = bool(byte & (uint(1) << uint(i)));
                }
                data[10*j+10] = bool(uint(cellL[j]) & (uint(1) << uint(w-1)) );
                data[10*j+19] = bool(uint(cellR[j]) & (uint(1) << uint(0)) );
            }
            for(int i = 0; i < w; i++) {
                data[i+1] = bool(byteT & (uint(1) << uint(i)));
                data[i+51] = bool(byteB & (uint(1) << uint(i)));
            }
            for(int j = 0; j < 2; j++) {
                for(int i = 0; i < 2; i++) {
                    uint byteCorner = uint(texelFetch(tex, xy + ivec2(2*i-1, 2*j-1), 0)[3*(1-j)] * 255.0);
                    data[50*j+9*i] = bool(byteCorner & (uint(1) << uint((w-1)*(1-i))));
                }
            }
            return data;
        }

        bool getProcessedBit(bool[9] box) {

            // rotation 270°
            // sel_4_1     sel_4_2     sel_4_3
            // 1,1,1       1,1,0       0,1,1
            // 0,0,0       0,0,2       2,0,0
            // 0,2,0       0,2,0       0,2,0

            // sel_4_1  270° rotation:
            bool val0 = box[0];     // Hit at above_left (-1, -1)
            val0 = val0 && box[1];     // Hit at above (0, -1)
            val0 = val0 && box[2];     // Hit at above_right (1, -1)
            val0 = val0 && (!box[7]);     // Miss at below (0, 1)

            // sel_4_2  270° rotation:
            bool val1 = box[0];     // Hit at above_left (-1, -1)
            val1 = val1 && box[1];     // Hit at above (0, -1)
            val1 = val1 && (!box[5]);     // Miss at right (1, 0)
            val1 = val1 && (!box[7]);     // Miss at below (0, 1)

            // sel_4_3  270° rotation:
            bool val2 = box[1];     // Hit at above (0, -1)
            val2 = val2 && box[2];     // Hit at above_right (1, -1)
            val2 = val2 && (!box[3]);     // Miss at left (-1, 0)
            val2 = val2 && (!box[7]);     // Miss at below (0, 1)


            bool val = val0 || val1 || val2;
            val = box[4] && (!val); // box[4] - center pixel

            return !val;
        }


        void main() {

            bool[60] data = getDataBock(p_texture, iwidth, iheight);

            // process main 32 bits and pack the result back into the pixel
            vec4 bytes = vec4(0.0, 0.0, 0.0, 0.0);
            for (int j = 0; j < iheight; j++) {
                uint byteValue = uint(0);
                for(int i = 0; i < iwidth; i++) {
                    int cXY = 10*j + i; // corner XY index for (-1,-1) to (1,1) box

                    // inversions due to Leptonica internal binary treating 1 as ink
                    // Leptonica converts < 60 to 1(ink) and >= 60 to 0(background)
                    // so it thickens black and thins white (for thinning)
                    bool[9] box = bool[9](
                        !data[cXY], !data[cXY+1], !data[cXY+2],
                        !data[cXY+10], !data[cXY+11], !data[cXY+12],
                        !data[cXY+20], !data[cXY+21], !data[cXY+22]
                    );
                    if (getProcessedBit(box)) {
                        byteValue =  byteValue | (uint(1) << uint(i));
                    }
                }
                bytes[j] = float(byteValue) / 255.0; // normalize to [0, 1] range
            }

            outColor = bytes;
        }
    </script>



    <!-- Fragment shader program -->
    <script id="unpacking-fs" type="x-shader/x-fragment">
        #version 300 es
        // precision mediump float;
        precision highp float;
        uniform sampler2D p_texture;
        out vec4 outColor;

        int iwidth = 8; // width of the pixel block, packed into 8 bits
        int iheight = 4; // height of the pixel block, packed into RGBA channels

        void main() {

            ivec2 xyOrig = ivec2(gl_FragCoord.xy - 0.5);
            int dx = xyOrig.x % iwidth;
            int dy = xyOrig.y % iheight; // to decide index in .rgba array
            int x = (xyOrig.x - dx) / iwidth;
            int y = (xyOrig.y - dy) / iheight;

            uint byte = uint( texelFetch(p_texture, ivec2(x,y), 0)[dy] * 255.0 );
            uint bit = byte & (uint(1) << uint(dx));
            float val = float(bool(bit));
            outColor = vec4(val, val, val, 1.0);
        }
    </script>

    <!-- Fragment shader program -->
    <script id="comparison-fs" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;

        uniform sampler2D src_texture;
        uniform sampler2D p_texture;
        uniform float u_threshold;

        out vec4 outColor;

        void main() {
            ivec2 texCoord = ivec2(gl_FragCoord.xy - 0.5);
            vec4 color1 = texelFetch(src_texture, texCoord, 0);
            vec4 color2 = texelFetch(p_texture, texCoord, 0);

            if(all(lessThan(abs(color1 - color2), vec4(u_threshold)))) {
                discard;
            }

            // Otherwise output difference, or something, doesn't matter
            outColor = abs(color1 - color2);
        }
    </script>

    <!-- Fragment shader program -->
    <script id="copy-fs" type="x-shader/x-fragment">
        #version 300 es
        // precision mediump float;
        precision highp float;
        uniform sampler2D up_texture;
        out vec4 outColor;

        void main() {
            ivec2 texCoord = ivec2(gl_FragCoord.xy - 0.5);
            outColor = texelFetch(up_texture, texCoord, 0);
        }
    </script>




            <script type="module">
                const footer = document.querySelector("footer");
                document.body.appendChild(
                    document.createElement("screen-logger"),
                );
                document.body.insertBefore(
                    document.createElement("media-menu"),
                    footer
                );
            </script>

            <script type="module" src="./utils/Logger.js"></script>
            <script type="module" src="./mediaMenu.js"></script>
        </main>

        <footer>
            <p>Kind of paradox</p>
        </footer>
    </body>
</html>
